#@page_fan_adds_unique = http_get(object_id,'page_fan_adds_unique',fecha_inicio,fecha_final,access_token)
#@page_fan_removes_unique = http_get(object_id,'page_fan_removes_unique',fecha_inicio,fecha_final,access_token)
#@page_impressions_organic = http_get(object_id,'page_impressions_organic',fecha_inicio,fecha_final,access_token)
#@page_storytellers = http_get(object_id,'page_storytellers',fecha_inicio,fecha_final,access_token)
#@page_impressions_organic_unique = http_get(object_id,'page_impressions_organic_unique',fecha_inicio,fecha_final,access_token)
#@page_consumptions_unique = http_get(object_id,'page_consumptions_unique',fecha_inicio,fecha_final,access_token)
#@page_impressions_unique = http_get(object_id,'page_impressions_unique',fecha_inicio,fecha_final,access_token)
#@page_friends_of_fans = http_get(object_id,'page_friends_of_fans',fecha_inicio,fecha_final,access_token)
#@page_impressions = http_get(object_id,'page_impressions',fecha_inicio,fecha_final,access_token)

#calcular_datos()

#  # GET /revisions
#  # GET /revisions.json
#  def index
#    @revisions = Revision.all
#
#    respond_to do |format|
#      format.html # index.html.erb
#      format.json { render json: @revisions }
#    end
#  end
#
#  # GET /revisions/1
#  # GET /revisions/1.json
#  def show
#    @revision = Revision.find(params[:id])
#
#    respond_to do |format|
#      format.html # show.html.erb
#      format.json { render json: @revision }
#    end
#  end
#
#  # GET /revisions/new
#  # GET /revisions/new.json
#  def new
#    @revision = Revision.new
#
#    respond_to do |format|
#      format.html # new.html.erb
#      format.json { render json: @revision }
#    end
#  end
#
#  # GET /revisions/1/edit
#  def edit
#    @revision = Revision.find(params[:id])
#  end
#
#  # POST /revisions
#  # POST /revisions.json
#  def create
#    @revision = Revision.new(params[:revision])
#
#    respond_to do |format|
#      if @revision.save
#        format.html { redirect_to root_path, notice: 'Entrada creada exitosamente.' }
#        format.json { render json: @revision, status: :created, location: @revision }
#      else
#        format.html { render action: "new" }
#        format.json { render json: @revision.errors, status: :unprocessable_entity }
#      end
#    end
#  end
#
#  # PUT /revisions/1
#  # PUT /revisions/1.json
#  def update
#    @revision = Revision.find(params[:id])
#
#    respond_to do |format|
#      if @revision.update_attributes(params[:revision])
#        format.html { redirect_to root_path, notice: 'Entrada actualizada exitosamente.' }
#        format.json { head :ok }
#      else
#        format.html { render action: "edit" }
#        format.json { render json: @revision.errors, status: :unprocessable_entity }
#      end
#    end
#  end
#
#  # DELETE /revisions/1
#  # DELETE /revisions/1.json
#  def destroy
#    @revision = Revision.find(params[:id])
#    @revision.destroy
#
#    respond_to do |format|
#      format.html { redirect_to root_path }
#      format.json { head :ok }
#    end
#  end

  Scenario: Show Facebook data in a range
    When I visit 
  	Given a client named "Client1"
  	And a Facebook datum for client "Starbucks" with the following stats:
  		| start_date | end_date  | new_fans |
  		| 8/14/2012  | 8/20/2012 | 1000     |
  	When I find Facebook datum for "Starbucks" between "8/14/2012" and "8/20/2012"
  	Then I should have the following information:
  		| new_fans |
  		| 1000     |